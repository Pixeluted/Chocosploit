//
// Created by Pixeluted on 05/05/2025.
//

#include "Drawing.hpp"

#include "ldebug.h"
#include "stb/stb_image.hpp"
#include "stb/stb_image_resize2.hpp"

static int color3Tag;
static int vector2Tag;

ImVec4 ConvertColor3ToImVec4(lua_State *L, const int index) {
    luaL_checktype(L, index, LUA_TUSERDATA);
    if (lua_userdatatag(L, index) != color3Tag)
        luaL_argerrorL(L, index, "Expected Color3");

    lua_pushvalue(L, index);

    lua_getfield(L, -2, "R");
    const auto R = lua_tonumber(L, -1);
    lua_pop(L, 1);

    lua_getfield(L, -2, "G");
    const auto G = lua_tonumber(L, -1);
    lua_pop(L, 1);

    lua_getfield(L, -2, "B");
    const auto B = lua_tonumber(L, -1);
    lua_pop(L, 1);

    lua_pop(L, 1);

    return ImVec4{
        static_cast<float>(R),
        static_cast<float>(G),
        static_cast<float>(B),
        1.0f
    };
}

ImVec2 ConvertVector2ToImVec2(lua_State *L, const int index) {
    luaL_checktype(L, index, LUA_TUSERDATA);
    if (lua_userdatatag(L, index) != vector2Tag)
        luaL_argerrorL(L, index, "Expected Vector2");

    lua_pushvalue(L, index);

    lua_getfield(L, -2, "X");
    const auto X = lua_tonumber(L, -1);
    lua_pop(L, 1);

    lua_getfield(L, -2, "Y");
    const auto Y = lua_tonumber(L, -1);
    lua_pop(L, 1);

    lua_pop(L, 1);
    return ImVec2{
        static_cast<float>(X),
        static_cast<float>(Y)
    };
}

void ConvertImVec2ToVector2(lua_State *L, const ImVec2 &imvec) {
    lua_getglobal(L, "Vector2");
    lua_getfield(L, -1, "new");
    lua_pushnumber(L, imvec.x);
    lua_pushnumber(L, imvec.y);
    lua_call(L, 2, 1);
    lua_remove(L, -2); // Removes Vector2 table
}

void ConvertImVec4ToColor3(lua_State *L, const ImVec4 &imvec) {
    lua_getglobal(L, "Color3");
    lua_getfield(L, -1, "new");
    lua_pushnumber(L, imvec.x);
    lua_pushnumber(L, imvec.y);
    lua_pushnumber(L, imvec.z);
    lua_call(L, 3, 1);
    lua_remove(L, -2); // Removes Color3 table
}

int index_renderObject_destroy(lua_State *L) {
    CheckExploitObject(L, 1, DrawingObject);
    const auto drawing = luaL_toexploitobject(L, 1, DrawingObj);

    ApplicationContext::GetService<RenderManager>()->RemoveDrawObject(drawing);
    return 0;
}

int renderObject__index(lua_State *L) {
    CheckExploitObject(L, 1, DrawingObject);
    const auto drawing = luaL_toexploitobject(L, 1, DrawingObj);
    const std::string propertyName = luaL_checkstring(L, 2);

    if (propertyName == "Destroy" || propertyName == "Remove") {
        lua_getref(L, indexDestroyRef);
        return 1;
    }

    if (propertyName == "Visible") {
        lua_pushboolean(L, drawing->isVisible);
        return 1;
    }

    if (propertyName == "ZIndex") {
        lua_pushinteger(L, drawing->zIndex);
        return 1;
    }

    if (propertyName == "Transparency") {
        lua_pushnumber(L, drawing->transparency);
        return 1;
    }

    if (propertyName == "Color") {
        ConvertImVec4ToColor3(L, drawing->color);
        return 1;
    }

    if (propertyName == "__OBJECT_EXISTS") {
        const auto renderManager = ApplicationContext::GetService<RenderManager>();

        bool objectExists = false;
        for (const auto &obj: renderManager->activeDrawingObjects) {
            if (obj.get() == drawing.get()) {
                objectExists = true;
                break;
            }
        }

        lua_pushboolean(L, objectExists);
        return 1;
    }

    if (drawing->objectType == Line) {
        if (propertyName == "From") {
            ConvertImVec2ToVector2(L, drawing->line.from);
            return 1;
        }

        if (propertyName == "To") {
            ConvertImVec2ToVector2(L, drawing->line.to);
            return 1;
        }

        if (propertyName == "Thickness") {
            lua_pushnumber(L, drawing->line.thickness);
            return 1;
        }
    }

    if (drawing->objectType == Circle) {
        if (propertyName == "NumSides") {
            lua_pushinteger(L, drawing->circle.numsides);
            return 1;
        }

        if (propertyName == "Radius") {
            lua_pushnumber(L, drawing->circle.radius);
            return 1;
        }

        if (propertyName == "Position") {
            ConvertImVec2ToVector2(L, drawing->circle.position);
            return 1;
        }

        if (propertyName == "Thickness") {
            lua_pushnumber(L, drawing->circle.thickness);
            return 1;
        }

        if (propertyName == "Filled") {
            lua_pushboolean(L, drawing->circle.filled);
            return 1;
        }
    }

    if (drawing->objectType == Square) {
        if (propertyName == "Size") {
            ConvertImVec2ToVector2(L, drawing->square.size);
            return 1;
        }

        if (propertyName == "Position") {
            ConvertImVec2ToVector2(L, drawing->square.position);
            return 1;
        }

        if (propertyName == "Thickness") {
            lua_pushnumber(L, drawing->square.thickness);
            return 1;
        }

        if (propertyName == "Filled") {
            lua_pushboolean(L, drawing->square.filled);
            return 1;
        }
    }

    if (drawing->objectType == Quad) {
        if (propertyName == "PointA") {
            ConvertImVec2ToVector2(L, drawing->quad.pointA);
            return 1;
        }

        if (propertyName == "PointB") {
            ConvertImVec2ToVector2(L, drawing->quad.pointB);
            return 1;
        }

        if (propertyName == "PointC") {
            ConvertImVec2ToVector2(L, drawing->quad.pointC);
            return 1;
        }

        if (propertyName == "PointD") {
            ConvertImVec2ToVector2(L, drawing->quad.pointD);
            return 1;
        }

        if (propertyName == "Thickness") {
            lua_pushnumber(L, drawing->quad.thickness);
            return 1;
        }

        if (propertyName == "Filled") {
            lua_pushboolean(L, drawing->quad.filled);
            return 1;
        }
    }

    if (drawing->objectType == Triangle) {
        if (propertyName == "PointA") {
            ConvertImVec2ToVector2(L, drawing->triangle.pointA);
            return 1;
        }

        if (propertyName == "PointB") {
            ConvertImVec2ToVector2(L, drawing->triangle.pointB);
            return 1;
        }

        if (propertyName == "PointC") {
            ConvertImVec2ToVector2(L, drawing->triangle.pointC);
            return 1;
        }

        if (propertyName == "Thickness") {
            lua_pushnumber(L, drawing->triangle.thickness);
            return 1;
        }

        if (propertyName == "Filled") {
            lua_pushboolean(L, drawing->triangle.filled);
            return 1;
        }
    }

    if (drawing->objectType == Text) {
        if (propertyName == "Text") {
            lua_pushstring(L, drawing->text.text.c_str());
            return 1;
        }

        if (propertyName == "TextBounds") {
            ConvertImVec2ToVector2(L, drawing->text.textBounds);
            return 1;
        }

        if (propertyName == "Font") {
            lua_pushinteger(L, drawing->text.font);
            return 1;
        }

        if (propertyName == "Size") {
            lua_pushnumber(L, drawing->text.size);
            return 1;
        }

        if (propertyName == "Position") {
            ConvertImVec2ToVector2(L, drawing->text.position);
            return 1;
        }

        if (propertyName == "Center") {
            lua_pushboolean(L, drawing->text.center);
            return 1;
        }

        if (propertyName == "Outline") {
            lua_pushboolean(L, drawing->text.outline);
            return 1;
        }

        if (propertyName == "OutlineColor") {
            ConvertImVec4ToColor3(L, drawing->text.outlineColor);
            return 1;
        }
    }

    if (drawing->objectType == Image) {
        if (propertyName == "Data") {
            lua_pushlstring(L, reinterpret_cast<const char *>(drawing->image.data.data()),
                            drawing->image.data.size());
            return 1;
        }

        if (propertyName == "Size") {
            ConvertImVec2ToVector2(L, drawing->image.size);
            return 1;
        }

        if (propertyName == "Position") {
            ConvertImVec2ToVector2(L, drawing->image.position);
            return 1;
        }

        if (propertyName == "Rounding") {
            lua_pushnumber(L, drawing->image.rounding);
            return 1;
        }
    }

    luaL_argerrorL(L, 2, std::format("Unknown property '{}'", propertyName).c_str());
}

int renderObject__newindex(lua_State *L) {
    CheckExploitObject(L, 1, DrawingObject);
    const auto drawing = luaL_toexploitobject(L, 1, DrawingObj);
    const std::string propertyName = luaL_checkstring(L, 2);
    luaL_checkany(L, 3);

    if (propertyName == "Visible") {
        drawing->isVisible = luaL_checkboolean(L, 3);
        return 0;
    }

    if (propertyName == "ZIndex") {
        drawing->zIndex = luaL_checkinteger(L, 3);
        return 0;
    }

    if (propertyName == "Transparency") {
        drawing->transparency = luaL_checknumber(L, 3);
        return 0;
    }

    if (propertyName == "Color") {
        drawing->color = ConvertColor3ToImVec4(L, 3);
        return 0;
    }

    if (drawing->objectType == Line) {
        if (propertyName == "From") {
            drawing->line.from = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "To") {
            drawing->line.to = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "Thickness") {
            drawing->line.thickness = luaL_checknumber(L, 3);
            return 0;
        }
    }

    if (drawing->objectType == Circle) {
        if (propertyName == "NumSides") {
            drawing->circle.numsides = luaL_checkinteger(L, 3);
            return 0;
        }

        if (propertyName == "Radius") {
            drawing->circle.radius = luaL_checknumber(L, 3);
            return 0;
        }

        if (propertyName == "Position") {
            drawing->circle.position = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "Thickness") {
            drawing->circle.thickness = luaL_checknumber(L, 3);
            return 0;
        }

        if (propertyName == "Filled") {
            drawing->circle.filled = luaL_checkboolean(L, 3);
            return 0;
        }
    }

    if (drawing->objectType == Square) {
        if (propertyName == "Size") {
            drawing->square.size = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "Position") {
            drawing->square.position = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "Thickness") {
            drawing->square.thickness = luaL_checknumber(L, 3);
            return 0;
        }

        if (propertyName == "Filled") {
            drawing->square.filled = luaL_checkboolean(L, 3);
            return 0;
        }
    }

    if (drawing->objectType == Quad) {
        if (propertyName == "PointA") {
            drawing->quad.pointA = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "PointB") {
            drawing->quad.pointB = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "PointC") {
            drawing->quad.pointC = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "PointD") {
            drawing->quad.pointD = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "Thickness") {
            drawing->quad.thickness = luaL_checknumber(L, 3);
            return 0;
        }

        if (propertyName == "Filled") {
            drawing->quad.filled = luaL_checkboolean(L, 3);
            return 0;
        }
    }

    if (drawing->objectType == Triangle) {
        if (propertyName == "PointA") {
            drawing->triangle.pointA = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "PointB") {
            drawing->triangle.pointB = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "PointC") {
            drawing->triangle.pointC = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "Thickness") {
            drawing->triangle.thickness = luaL_checknumber(L, 3);
            return 0;
        }

        if (propertyName == "Filled") {
            drawing->triangle.filled = luaL_checkboolean(L, 3);
            return 0;
        }
    }

    if (drawing->objectType == Text) {
        if (propertyName == "Text") {
            drawing->text.text = luaL_checkstring(L, 3);
            drawing->UpdateTextBounds();
            return 0;
        }

        if (propertyName == "TextBounds") {
            luaL_argerrorL(L, 2, "Property is read-only");
        }

        if (propertyName == "Font") {
            const auto receivedNumber = luaL_checkinteger(L, 3);;
            if (receivedNumber < 0 || receivedNumber > 3)
                luaL_argerrorL(L, 3, "Invalid font provided");
            drawing->text.font = static_cast<TextFont>(receivedNumber);
            drawing->UpdateTextBounds();
            return 0;
        }

        if (propertyName == "Size") {
            drawing->text.size = luaL_checknumber(L, 3);
            drawing->UpdateTextBounds();
            return 0;
        }

        if (propertyName == "Position") {
            drawing->text.position = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "Center") {
            drawing->text.center = luaL_checkboolean(L, 3);
            return 0;
        }

        if (propertyName == "Outline") {
            drawing->text.outline = luaL_checkboolean(L, 3);
            return 0;
        }

        if (propertyName == "OutlineColor") {
            drawing->text.outlineColor = ConvertColor3ToImVec4(L, 3);
            return 0;
        }
    }

    if (drawing->objectType == Image) {
        if (propertyName == "Data") {
            size_t dataLength;
            const auto rawData = luaL_checklstring(L, 3, &dataLength);
            int original_width, original_height, channels;
            const auto decodedData = stbi_load_from_memory(reinterpret_cast<const unsigned char *>(rawData),
                                                           static_cast<int>(dataLength), &original_width,
                                                           &original_height, &channels,
                                                           STBI_rgb_alpha);


            if (decodedData) {
                int user_width = static_cast<int>(drawing->image.size.x);
                int user_height = static_cast<int>(drawing->image.size.y);
                if (user_width <= 0 || user_height <= 0) {
                    user_width = original_width;
                    user_height = original_height;
                    drawing->image.size = ImVec2(static_cast<float>(original_width),
                                                      static_cast<float>(original_height));
                }

                if (user_width != original_width || user_height != original_height) {
                    const size_t newDataSize = user_width * user_height * 4;
                    drawing->image.data.resize(newDataSize);

                    stbir_resize_uint8_srgb(
                        decodedData, original_width, original_height, 0, drawing->image.data.data(), user_width,
                        user_height, 0, STBIR_RGBA_PM
                    );
                } else {
                    const size_t dataSize = original_width * original_height * 4;
                    drawing->image.data.resize(dataSize);
                    memcpy(drawing->image.data.data(), decodedData, dataSize);
                }

                stbi_image_free(decodedData);
            } else {
                luaG_runerrorL(L, "Failed to load image!");
            }

            if (drawing->image.textureCreated && drawing->image.textureId) {
                reinterpret_cast<ID3D11ShaderResourceView *>(drawing->image.textureId)->Release();
                drawing->image.textureId = 0;
                drawing->image.textureCreated = false;
            }

            return 0;
        }

        if (propertyName == "Size") {
            const auto original_width = drawing->image.size.x;
            const auto original_height = drawing->image.size.y;

            drawing->image.size = ConvertVector2ToImVec2(L, 3);
            if (drawing->image.data.empty())
                return 0;

            const auto user_width = drawing->image.size.x;
            const auto user_height = drawing->image.size.y;
            if (original_width != user_width || original_height != user_height) {
                const auto originalData = drawing->image.data;
                const size_t newDataSize = user_width * user_height * 4;
                drawing->image.data.resize(newDataSize);

                stbir_resize_uint8_srgb(
                    originalData.data(), original_width, original_height, 0, drawing->image.data.data(),
                    user_width,
                    user_height, 0, STBIR_RGBA_PM
                );

                if (drawing->image.textureCreated && drawing->image.textureId) {
                    reinterpret_cast<ID3D11ShaderResourceView *>(drawing->image.textureId)->Release();
                    drawing->image.textureId = 0;
                    drawing->image.textureCreated = false;
                }
            }
            return 0;
        }

        if (propertyName == "Position") {
            drawing->image.position = ConvertVector2ToImVec2(L, 3);
            return 0;
        }

        if (propertyName == "Rounding") {
            drawing->image.rounding = luaL_checknumber(L, 3);
            return 0;
        }
    }

    luaL_argerrorL(L, 2, std::format("Unknown property '{}'", propertyName).c_str());
}

int renderObject__namecall(lua_State *L) {
    CheckExploitObject(L, 1, DrawingObject);
    const auto renderObject = luaL_toexploitobject(L, 1, DrawingObj);
    const std::string namecallName = lua_namecallatom(L, nullptr);

    if (namecallName == "Destroy" || namecallName == "Remove") {
        ApplicationContext::GetService<RenderManager>()->RemoveDrawObject(renderObject);
        return 0;
    }

    luaG_runerrorL(L, "Unknown method");
}

const char *DrawingObj::GetObjectMtName() {
    return "DrawingMt";
}

void DrawingObj::InitializeObjectMetatable(lua_State *L) {
    this->PushInheritedMt(L);

    lua_pushcfunction(L, renderObject__index, "RenderObject__Index");
    lua_setfield(L, -2, "__index");

    lua_pushcfunction(L, renderObject__newindex, "RenderObject__NewIndex");
    lua_setfield(L, -2, "__newindex");

    lua_pushcfunction(L, renderObject__namecall, "RenderObject__Namecall");
    lua_setfield(L, -2, "__namecall");

    lua_setreadonly(L, -1, true);
    lua_pop(L, 1);

    lua_pushcfunction(L, index_renderObject_destroy, "Destroy");
    indexDestroyRef = lua_ref(L, -1);
    lua_pop(L, 1); // Pop the function

    lua_getglobal(L, "Color3");
    lua_getfield(L, -1, "fromRGB");
    lua_pushnumber(L, 0);
    lua_pushnumber(L, 0);
    lua_pushnumber(L, 0);
    lua_call(L, 3, 1);
    lua_remove(L, -2); // Remove Color3
    color3Tag = lua_userdatatag(L, -1);
    lua_pop(L, 1); // Pop the new Color3

    lua_getglobal(L, "Vector2");
    lua_getfield(L, -1, "new");
    lua_pushnumber(L, 0);
    lua_pushnumber(L, 0);
    lua_call(L, 2, 1);
    lua_remove(L, -2); // Remove Vector2
    vector2Tag = lua_userdatatag(L, -1);
    lua_pop(L, 1); // Pop the new Vector2
}
