//
// Created by Pixeluted on 05/05/2025.
//

#include "Connection.hpp"

#include "ldebug.h"
#include "../../ApplicationContext.hpp"
#include "../../OffsetsAndFunctions.hpp"
#include "../../Execution/InternalTaskScheduler.hpp"

boolean ValidateConnection(const std::shared_ptr<Connection> &connectionInfo) {
    if (*reinterpret_cast<uint8_t *>(connectionInfo->connectionAddress) != 1) {
        connectionInfo->isValid = false;
        return false;
    }
    return true;
}

int Index_Fire(lua_State *L) {
    CheckExploitObject(L, 1, ConnectionObject);
    const auto connectionInfo = luaL_toexploitobject(L, 1, Connection);
    if (!connectionInfo->isValid)
        return 0;
    if (!ValidateConnection(connectionInfo))
        return 0;

    if (connectionInfo->isForeignState || !connectionInfo->isLuaConnection)
        return 0;

    if (connectionInfo->isWaitConnection) {
        lua_getref(L, connectionInfo->threadRefId);
        const auto suspendedThread = (lua_State *) lua_topointer(L, -1);
        auto weakThreadRef = WeakThreadRef{0, suspendedThread, connectionInfo->threadRefId, 0};
        auto threadRef = &weakThreadRef;
        int64_t results[0x2]{0};

        resumeThread(
            reinterpret_cast<void *>(ApplicationContext::GetService<InternalTaskScheduler>()->currentState->
                                     currentScriptContext +
                                     ChocoSploit::StructOffsets::ScriptContext::ResumeFaceOffset), results,
            &threadRef,
            0,
            false,
            "");

        connectionInfo->isValid = false;
        DisconnectConnection(&connectionInfo->connectionAddress);
        return 0;
    }

    lua_remove(L, 1); // Pop the connection object
    lua_getref(L, connectionInfo->functionRefId);
    lua_insert(L, 1);

    Task_Spawn(L);
    if (connectionInfo->isOnceConnection) {
        connectionInfo->isValid = false;
        DisconnectConnection(&connectionInfo->connectionAddress);
    }
    return 0;
}


int Index_Defer(lua_State *L) {
    CheckExploitObject(L, 1, ConnectionObject);
    const auto connectionInfo = luaL_toexploitobject(L, 1, Connection);
    if (!connectionInfo->isValid)
        return 0;
    if (!ValidateConnection(connectionInfo))
        return 0;

    if (connectionInfo->isForeignState || !connectionInfo->isLuaConnection)
        return 0;

    if (connectionInfo->isWaitConnection) {
        lua_getref(L, connectionInfo->threadRefId);
        const auto suspendedThread = (lua_State *) lua_topointer(L, -1);
        auto weakThreadRef = WeakThreadRef{0, suspendedThread, connectionInfo->threadRefId, 0};
        auto threadRef = &weakThreadRef;
        int64_t results[0x2]{0};

        resumeThread(
            reinterpret_cast<void *>(ApplicationContext::GetService<InternalTaskScheduler>()->currentState->
                                     currentScriptContext +
                                     ChocoSploit::StructOffsets::ScriptContext::ResumeFaceOffset), results,
            &threadRef,
            0,
            false,
            "");

        connectionInfo->isValid = false;
        DisconnectConnection(&connectionInfo->connectionAddress);
        return 0;
    }

    lua_remove(L, 1); // Pop the connection object
    lua_getref(L, connectionInfo->functionRefId);
    lua_insert(L, 1);

    Task_Defer(L);
    if (connectionInfo->isOnceConnection) {
        connectionInfo->isValid = false;
        DisconnectConnection(&connectionInfo->connectionAddress);
    }
    return 0;
}

int Index_Enable(lua_State *L) {
    CheckExploitObject(L, 1, ConnectionObject);
    const auto connectionInfo = luaL_toexploitobject(L, 1, Connection);
    if (!connectionInfo->isValid)
        return 0;
    if (!ValidateConnection(connectionInfo))
        return 0;

    *reinterpret_cast<uintptr_t *>(connectionInfo->connectionAddress +
                                   ChocoSploit::StructOffsets::Signal::enabled) = connectionInfo->
            originalEnabledValue;
    return 0;
}

int Index_Disconnect(lua_State *L) {
    CheckExploitObject(L, 1, ConnectionObject);
    const auto connectionInfo = luaL_toexploitobject(L, 1, Connection);
    if (!connectionInfo->isValid)
        return 0;
    if (!ValidateConnection(connectionInfo))
        return 0;

    DisconnectConnection(&connectionInfo->connectionAddress);
    connectionInfo->isValid = false;
    return 0;
}

int Index_Disable(lua_State *L) {
    CheckExploitObject(L, 1, ConnectionObject);
    const auto connectionInfo = luaL_toexploitobject(L, 1, Connection);
    if (!connectionInfo->isValid)
        return 0;
    if (!ValidateConnection(connectionInfo))
        return 0;

    *reinterpret_cast<uintptr_t *>(connectionInfo->connectionAddress +
                                   ChocoSploit::StructOffsets::Signal::enabled) = 0;
    return 0;
}

int Connection__Index(lua_State *L) {
    CheckExploitObject(L, 1, ConnectionObject);
    luaL_checktype(L, 2, LUA_TSTRING);
    const auto connectionInfo = luaL_toexploitobject(L, 1, Connection);
    if (!connectionInfo->isValid)
        return 0;
    if (!ValidateConnection(connectionInfo))
        return 0;

    const std::string indexKey = lua_tostring(L, 2);

    if (indexKey == "Fire") {
        lua_getref(L, indexFireRef);
        return 1;
    }

    if (indexKey == "Defer") {
        lua_getref(L, indexDeferRef);
        return 1;
    }

    if (indexKey == "Enable") {
        lua_getref(L, indexEnableRef);
        return 1;
    }

    if (indexKey == "Disable") {
        lua_getref(L, indexDisableRef);
        return 1;
    }

    if (indexKey == "Disconnect") {
        lua_getref(L, indexDisconnectRef);
        return 1;
    }

    if (indexKey == "IsOnceConnection") {
        lua_pushboolean(L, connectionInfo->isOnceConnection);
        return 1;
    }

    if (indexKey == "IsWaitConnection") {
        lua_pushboolean(L, connectionInfo->isWaitConnection);
        return 1;
    }

    if (indexKey == "Enabled") {
        lua_pushboolean(
            L, *reinterpret_cast<uintptr_t *>(connectionInfo->connectionAddress +
                                              ChocoSploit::StructOffsets::Signal::enabled) != 0);
        return 1;
    }

    if (indexKey == "ForeignState") {
        lua_pushboolean(L, connectionInfo->isForeignState);
        return 1;
    }

    if (indexKey == "LuaConnection") {
        lua_pushboolean(L, connectionInfo->isLuaConnection);
        return 1;
    }

    if (indexKey == "Function") {
        if (!connectionInfo->isLuaConnection || connectionInfo->isForeignState || connectionInfo->isWaitConnection) {
            lua_pushnil(L);
            return 1;
        }

        lua_getref(L, connectionInfo->functionRefId);
        return 1;
    }

    if (indexKey == "Thread") {
        if (!connectionInfo->isLuaConnection || connectionInfo->isForeignState) {
            lua_pushnil(L);
            return 1;
        }

        lua_getref(L, connectionInfo->threadRefId);
        return 1;
    }

    luaL_argerrorL(L, 2, std::format("Unknown property {}", indexKey).c_str());
}

int Connection__Namecall(lua_State *L) {
    CheckExploitObject(L, 1, ConnectionObject);
    const auto connectionInfo = luaL_toexploitobject(L, 1, Connection);
    if (!connectionInfo->isValid)
        return 0;
    if (!ValidateConnection(connectionInfo))
        return 0;

    const std::string namecallName = lua_namecallatom(L, nullptr);

    /**
    if (namecallName == "CopyAddress") {
        const auto theAddress = std::format("0x{:x}", connectionInfo->connectionAddress);
        lua_getglobal(L, "setclipboard");
        lua_pushstring(L, theAddress.c_str());
        lua_call(L, 1, 0);
        return 0;
    }
    */

    if (namecallName == "Fire") {
        if (connectionInfo->isForeignState || !connectionInfo->isLuaConnection)
            return 0;

        if (connectionInfo->isWaitConnection) {
            lua_getref(L, connectionInfo->threadRefId);
            const auto suspendedThread = (lua_State *) lua_topointer(L, -1);
            auto weakThreadRef = WeakThreadRef{0, suspendedThread, connectionInfo->threadRefId, 0};
            auto threadRef = &weakThreadRef;
            int64_t results[0x2]{0};

            resumeThread(
                reinterpret_cast<void *>(ApplicationContext::GetService<InternalTaskScheduler>()->currentState->
                                         currentScriptContext +
                                         ChocoSploit::StructOffsets::ScriptContext::ResumeFaceOffset), results,
                &threadRef,
                0,
                false,
                "");

            connectionInfo->isValid = false;
            DisconnectConnection(&connectionInfo->connectionAddress);
            return 0;
        }

        lua_remove(L, 1); // Pop the connection object
        lua_getref(L, connectionInfo->functionRefId);
        lua_insert(L, 1);

        Task_Spawn(L);
        if (connectionInfo->isOnceConnection) {
            connectionInfo->isValid = false;
            DisconnectConnection(&connectionInfo->connectionAddress);
        }
        return 0;
    }

    if (namecallName == "Defer") {
        if (connectionInfo->isForeignState || !connectionInfo->isLuaConnection)
            return 0;

        if (connectionInfo->isWaitConnection) {
            lua_getref(L, connectionInfo->threadRefId);
            const auto suspendedThread = (lua_State *) lua_topointer(L, -1);
            auto weakThreadRef = WeakThreadRef{0, suspendedThread, connectionInfo->threadRefId, 0};
            auto threadRef = &weakThreadRef;
            int64_t results[0x2]{0};

            resumeThread(
                reinterpret_cast<void *>(ApplicationContext::GetService<InternalTaskScheduler>()->currentState->
                                         currentScriptContext +
                                         ChocoSploit::StructOffsets::ScriptContext::ResumeFaceOffset), results,
                &threadRef,
                0,
                false,
                "");

            connectionInfo->isValid = false;
            DisconnectConnection(&connectionInfo->connectionAddress);
            return 0;
        }

        lua_remove(L, 1); // Pop the connection object
        lua_getref(L, connectionInfo->functionRefId);
        lua_insert(L, 1);

        Task_Defer(L);
        if (connectionInfo->isOnceConnection) {
            connectionInfo->isValid = false;
            DisconnectConnection(&connectionInfo->connectionAddress);
        }
        return 0;
    }

    if (namecallName == "Enable") {
        *reinterpret_cast<uintptr_t *>(connectionInfo->connectionAddress +
                                       ChocoSploit::StructOffsets::Signal::enabled) = connectionInfo->
                originalEnabledValue;
        return 0;
    }

    if (namecallName == "Disable") {
        *reinterpret_cast<uintptr_t *>(connectionInfo->connectionAddress +
                                       ChocoSploit::StructOffsets::Signal::enabled) = 0;
        return 0;
    }

    if (namecallName == "Disconnect") {
        DisconnectConnection(&connectionInfo->connectionAddress);
        connectionInfo->isValid = false;
        return 0;
    }

    luaL_argerrorL(L, 2, std::format("Unknown method {}", namecallName).c_str());
}

int Connection__Newindex(lua_State *L) {
    luaG_runerrorL(L, "Signals are read-only");
}

void NewConnection(lua_State *L, const uintptr_t connectionAddr) {
    const auto connectionInfo = std::make_shared<Connection>();

    const auto connectionSlot = *reinterpret_cast<uintptr_t *>(
        connectionAddr + ChocoSploit::StructOffsets::Signal::signalSlot);

    connectionInfo->connectionAddress = connectionAddr;
    if (IsBadReadPtr(reinterpret_cast<void *>(connectionSlot), 0x10)) {
        connectionInfo->isLuaConnection = false;
    } else {
        const auto signalSlotWrapper = *reinterpret_cast<uintptr_t *>(
            connectionAddr + ChocoSploit::StructOffsets::Signal::signalSlotWrapper);
        const auto refPointer = *reinterpret_cast<uintptr_t *>(
            signalSlotWrapper +
            ChocoSploit::StructOffsets::Signal::SignalSlotWrapper::Ptr);
        const auto refPointer2 = *reinterpret_cast<uintptr_t *>(
            signalSlotWrapper + ChocoSploit::StructOffsets::Signal::SignalSlotWrapper::secondPtr);
        const auto refPointer3 = *reinterpret_cast<uintptr_t *>(
            signalSlotWrapper + ChocoSploit::StructOffsets::Signal::SignalSlotWrapper::thirdPtr);

        connectionInfo->isLuaConnection = refPointer != connectionSlot && refPointer2 != connectionSlot && refPointer3
                                          != connectionSlot;
    }

    connectionInfo->originalEnabledValue = *reinterpret_cast<uintptr_t *>(
        connectionInfo->connectionAddress + ChocoSploit::StructOffsets::Signal::enabled);
    connectionInfo->isValid = true;

    if (connectionInfo->isLuaConnection) {
        if (*reinterpret_cast<uintptr_t *>(connectionSlot +
                                           ChocoSploit::StructOffsets::Signal::WaitSlot::checkPointer) == 0) {
            // This is a Wait signal!
            connectionInfo->isWaitConnection = true;
            bool usedThirdRef = false;
            auto connectionRefs = *reinterpret_cast<uintptr_t *>(
                connectionSlot + ChocoSploit::StructOffsets::Signal::WaitSlot::connectionRefs);
            if (connectionRefs == 0 || IsBadReadPtr(reinterpret_cast<void *>(connectionRefs), 0x10)) {
                connectionRefs = *reinterpret_cast<uintptr_t *>(
                    connectionSlot + ChocoSploit::StructOffsets::Signal::WaitSlot::connectionRefs2);
                if (connectionRefs == 0 || IsBadReadPtr(reinterpret_cast<void *>(connectionRefs), 0x10)) {
                    connectionRefs = *reinterpret_cast<uintptr_t *>(
                        connectionSlot + ChocoSploit::StructOffsets::Signal::WaitSlot::connectionRefs3);
                    if (connectionRefs == 0 || IsBadReadPtr(reinterpret_cast<void *>(connectionRefs), 0x10)) {
                        MessageBoxA(nullptr, "This shouldn't happen, please report this.", "Notice", MB_OK);
                        MessageBoxA(nullptr, std::format("Unsupported wait connection: 0x{:x}", connectionAddr).c_str(),
                                    "Notice", MB_OK);
                        lua_pushnil(L);
                        return;
                    } else {
                        usedThirdRef = true;
                    }
                }
            }

            auto threadRefContainer = *reinterpret_cast<uintptr_t *>(
                connectionRefs + (usedThirdRef
                                      ? ChocoSploit::StructOffsets::Signal::WaitSlot::threadRefContainer2
                                      : ChocoSploit::StructOffsets::Signal::WaitSlot::threadRefContainer));
            if (threadRefContainer == 0) {
                threadRefContainer = *reinterpret_cast<uintptr_t*>(connectionRefs + ChocoSploit::StructOffsets::Signal::WaitSlot::threadRefContainer3);
            }

            const auto threadRef = *reinterpret_cast<uintptr_t *>(
                threadRefContainer + ChocoSploit::StructOffsets::Signal::WaitSlot::threadRef);

            connectionInfo->threadRefId = *reinterpret_cast<uint32_t *>(
                threadRef + ChocoSploit::StructOffsets::Signal::SignalSlot::Refs::luaThreadRefId);
            const auto thread = *reinterpret_cast<lua_State **>(
                threadRef + ChocoSploit::StructOffsets::Signal::SignalSlot::Refs::luaThread);
            connectionInfo->isForeignState = thread->global->mainthread != L->global->mainthread;
        } else {
            // This is a normal connection
            connectionInfo->isOnceConnection = *reinterpret_cast<uint8_t *>(
                                                   connectionSlot +
                                                   ChocoSploit::StructOffsets::Signal::SignalSlot::isOnce) == 1;
            const auto connectionRefs = *reinterpret_cast<uintptr_t *>(
                connectionSlot + ChocoSploit::StructOffsets::Signal::SignalSlot::SignalRefs);
            connectionInfo->threadRefId = *reinterpret_cast<uint32_t *>(
                connectionRefs + ChocoSploit::StructOffsets::Signal::SignalSlot::Refs::luaThreadRefId);
            connectionInfo->functionRefId = *reinterpret_cast<uint32_t *>(
                connectionRefs + ChocoSploit::StructOffsets::Signal::SignalSlot::Refs::functionRefId);

            const auto luaThread = *reinterpret_cast<lua_State **>(
                connectionRefs + ChocoSploit::StructOffsets::Signal::SignalSlot::Refs::luaThread);
            connectionInfo->isForeignState = luaThread->global->mainthread != L->global->mainthread;
        }
    }

    connectionInfo->BuildLuaObject(L, connectionInfo);
}

const char *Connection::GetObjectMtName() {
    return "ConnectionMt";
}

void Connection::InitializeObjectMetatable(lua_State *L) {
    this->PushInheritedMt(L);
    lua_pushcfunction(L, Connection__Index, "UnnamedConnection_Index");
    lua_setfield(L, -2, "__index");

    lua_pushcfunction(L, Connection__Namecall, "UnnamedConnection_Namecall");
    lua_setfield(L, -2, "__namecall");

    lua_pushcfunction(L, Connection__Newindex, "UnnamedConnection_Newindex");
    lua_setfield(L, -2, "__newindex");

    lua_setreadonly(L, -1, true);
    lua_pop(L, 1);

    lua_pushcfunction(L, Index_Fire, "Fire");
    indexFireRef = lua_ref(L, -1);
    lua_pop(L, 1);

    lua_pushcfunction(L, Index_Defer, "Defer");
    indexDeferRef = lua_ref(L, -1);
    lua_pop(L, 1);

    lua_pushcfunction(L, Index_Enable, "Enable");
    indexEnableRef = lua_ref(L, -1);
    lua_pop(L, 1);

    lua_pushcfunction(L, Index_Disable, "Disable");
    indexDisableRef = lua_ref(L, -1);
    lua_pop(L, 1);

    lua_pushcfunction(L, Index_Disconnect, "Disconnect");
    indexDisconnectRef = lua_ref(L, -1);
    lua_pop(L, 1);
}
