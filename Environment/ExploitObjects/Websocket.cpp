//
// Created by Pixeluted on 05/05/2025.
//

#include "Websocket.hpp"

#include "ldebug.h"
#include "../../ApplicationContext.hpp"
#include "../../Execution/InternalTaskScheduler.hpp"

__forceinline void CreateRobloxInstance(lua_State *L, const char *instanceClassName) {
    lua_getglobal(L, "Instance");
    lua_getfield(L, -1, "new");
    lua_pushstring(L, instanceClassName);
    lua_call(L, 1, 1);
    lua_remove(L, -2); // Pop instance table
}

int Websocket_IndexSend(lua_State *L) {
    CheckExploitObject(L, 1, WebsocketObject);
    const auto websocketInstance = luaL_toexploitobject(L, 1, Websocket);
    luaL_checktype(L, 2, LUA_TSTRING);

    if (!websocketInstance->isUseable)
        return 0;

    size_t contentLength;
    const auto contentToSend = lua_tolstring(L, 2, &contentLength);

    if (websocketInstance->websocketObject->getReadyState() == ix::ReadyState::Open) {
        websocketInstance->websocketObject->sendText(std::string(contentToSend, contentLength));
    }

    return 0;
}

int Websocket_IndexClose(lua_State *L) {
    CheckExploitObject(L, 1, WebsocketObject);
    const auto websocketInstance = luaL_toexploitobject(L, 1, Websocket);
    if (!websocketInstance->isUseable)
        return 0;

    CloseWebsocketInstance(websocketInstance);
    return 0;
}

int Websocket_Index(lua_State *L) {
    CheckExploitObject(L, 1, WebsocketObject);
    const auto websocketInstance = luaL_toexploitobject(L, 1, Websocket);
    const auto keyName = luaL_checkstring(L, 2);

    if (strcmp(keyName, "OnMessage") == 0 && websocketInstance->isUseable) {
        lua_getref(L, websocketInstance->onMessageRef);
        lua_getfield(L, -1, "Event");
        return 1;
    }
    if (strcmp(keyName, "OnClose") == 0 && websocketInstance->isUseable) {
        lua_getref(L, websocketInstance->onCloseRef);
        lua_getfield(L, -1, "Event");
        return 1;
    }
    if (strcmp(keyName, "Send") == 0) {
        lua_getref(L, indexSendRef);
        return 1;
    }
    if (strcmp(keyName, "Close") == 0) {
        lua_getref(L, indexCloseRef);
        return 1;
    }

    luaL_argerrorL(L, 2, "Unknown property");
}

int Websocket_Newindex(lua_State *L) {
    luaG_runerrorL(L, "Websockets are read-only");
}

int Websocket_Namecall(lua_State *L) {
    CheckExploitObject(L, 1, WebsocketObject);
    const auto websocketInstance = luaL_toexploitobject(L, 1, Websocket);
    const auto namecallName = lua_namecallatom(L, nullptr);
    if (!websocketInstance->isUseable)
        return 0;

    if (strcmp(namecallName, "Send") == 0) {
        luaL_checktype(L, 2, LUA_TSTRING);
        size_t contentLength;
        const auto contentToSend = lua_tolstring(L, 2, &contentLength);

        if (websocketInstance->websocketObject->getReadyState() == ix::ReadyState::Open) {
            websocketInstance->websocketObject->sendText(std::string(contentToSend, contentLength));
        }

        return 0;
    }

    if (strcmp(namecallName, "Close") == 0) {
        CloseWebsocketInstance(websocketInstance);
        return 0;
    }

    luaG_runerrorL(L, "Unknown method");
}

const char *Websocket::GetObjectMtName() {
    return "WebsocketMt";
}

void Websocket::InitializeObjectMetatable(lua_State *L) {
    this->PushInheritedMt(L);

    lua_pushcclosure(L, Websocket_Index, "Websocket_Index", 0);
    lua_setfield(L, -2, "__index");

    lua_pushcclosure(L, Websocket_Newindex, "Websocket_Newindex", 0);
    lua_setfield(L, -2, "__newindex");

    lua_pushcclosure(L, Websocket_Namecall, "Websocket_Namecall", 0);
    lua_setfield(L, -2, "__namecall");

    lua_setreadonly(L, -1, true);
    lua_pop(L, 1);

    lua_pushcclosure(L, Websocket_IndexSend, "Ws_Send", 0);
    indexSendRef = lua_ref(L, -1);
    lua_pop(L, 1);

    lua_pushcclosure(L, Websocket_IndexClose, "Ws_Close", 0);
    indexCloseRef = lua_ref(L, -1);
    lua_pop(L, 1);
}

Websocket::~Websocket() {
    if (isUseable && !isClosing) {
        std::shared_ptr<Websocket> tempShared(this, [](Websocket *) {});
        CloseWebsocketInstance(tempShared);
    }
}

void CloseWebsocketInstance(const std::shared_ptr<Websocket> &instance,
                                              const bool fireClosedConnection) {
    if (instance->isClosing)
        return;

    instance->isClosing = true;
    instance->isUseable = false;
    if (fireClosedConnection) {
        ApplicationContext::GetService<InternalTaskScheduler>()->ScheduleLuaDispatch([instance](lua_State *L) {
            lua_getref(L, instance->onCloseRef);
            lua_getfield(L, -1, "Fire");
            lua_pushvalue(L, -2);
            lua_call(L, 1, 0);
        });
    }

    instance->websocketObject->stop();

    ApplicationContext::GetService<InternalTaskScheduler>()->ScheduleLuaDispatch([instance](lua_State *L) {
        lua_getref(L, instance->onMessageRef);
        lua_unref(L, instance->onMessageRef);
        lua_getfield(L, -1, "Destroy");
        lua_pushvalue(L, -2);
        lua_call(L, 1, 0);

        lua_getref(L, instance->onCloseRef);
        lua_unref(L, instance->onCloseRef);
        lua_getfield(L, -1, "Destroy");
        lua_pushvalue(L, -2);
        lua_call(L, 1, 0);

        lua_unref(L, instance->userdataRef);
    });
}

std::shared_ptr<Websocket> CreateNewWebsocket(lua_State *L, const std::string &websocketUrl) {
    const auto newWebsocket = std::make_shared<Websocket>();
    newWebsocket->websocketObject = std::make_shared<ix::WebSocket>();
    newWebsocket->websocketObject->setUrl(websocketUrl);
    newWebsocket->websocketObject->setPingInterval(1);
    newWebsocket->websocketObject->disableAutomaticReconnection();
    const auto weakPtr = std::weak_ptr(newWebsocket);
    newWebsocket->websocketObject->setOnMessageCallback([weakPtr](const ix::WebSocketMessagePtr &msg) {
        if (weakPtr.expired())
            return;
        const auto newWebsocket = weakPtr.lock();
        if (!newWebsocket->isUseable)
            return;
        if (msg->type == ix::WebSocketMessageType::Message) {
            const auto message = msg->str;
            const auto isBinaryMessage = msg->binary;
            ApplicationContext::GetService<InternalTaskScheduler>()->ScheduleLuaDispatch(
                [message, isBinaryMessage, newWebsocket](lua_State *L) {
                    lua_getref(L, newWebsocket->onMessageRef);
                    lua_getfield(L, -1, "Fire");
                    lua_pushvalue(L, -2);
                    lua_pushlstring(L, message.c_str(), message.length());
                    lua_pushboolean(L, isBinaryMessage);
                    lua_call(L, 3, 0);
                });
        }

        switch (msg->type) {
            case ix::WebSocketMessageType::Error:
                newWebsocket->lastWebsocketErrorMessage = msg->errorInfo.reason;
                break;
            case ix::WebSocketMessageType::Close:
                ApplicationContext::GetService<InternalTaskScheduler>()->ScheduleLuaDispatch(
                    [newWebsocket](lua_State *L) {
                        if (newWebsocket->isClosing) return;
                        CloseWebsocketInstance(newWebsocket);
                    });
                break;
            default:
                break;
        }
    });

    CreateRobloxInstance(L, "BindableEvent");
    newWebsocket->onMessageRef = lua_ref(L, -1);
    lua_pop(L, 1);

    CreateRobloxInstance(L, "BindableEvent");
    newWebsocket->onCloseRef = lua_ref(L, -1);
    lua_pop(L, 1);

    newWebsocket->userdataRef = lua_ref(L, -1);;
    newWebsocket->isUseable = true;

    return newWebsocket;
}
